{"version":3,"file":"component---src-components-blog-post-layout-js-content-file-path-d-coding-blog-content-life-expereinced-vs-young-software-architects-mdx-3d762df937931767a9f1.js","mappings":"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","sources":["webpack://aimless-analysis/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://aimless-analysis/./node_modules/@mdx-js/react/lib/index.js","webpack://aimless-analysis/./content/life/expereinced_vs_young_software_architects.mdx","webpack://aimless-analysis/./src/components/blog-post-layout.js"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _defineProperty from \"D:/coding/blog/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode} [children]\n *   Children.\n *\n * @callback MergeComponents\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react';\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport var MDXContext = React.createContext({});\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means it’s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent;\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    var allComponents = useMDXComponents(props.components);\n    return React.createElement(Component, _objectSpread(_objectSpread({}, props), {}, {\n      allComponents: allComponents\n    }));\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components|MergeComponents} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  var contextComponents = React.useContext(MDXContext);\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(function () {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents);\n    }\n    return _objectSpread(_objectSpread({}, contextComponents), components);\n  }, [contextComponents, components]);\n}\n\n/** @type {Components} */\nvar emptyObject = {};\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider(_ref) {\n  var components = _ref.components,\n    children = _ref.children,\n    disableParentContext = _ref.disableParentContext;\n  var allComponents = useMDXComponents(components);\n  if (disableParentContext) {\n    allComponents = components || emptyObject;\n  }\n  return React.createElement(MDXContext.Provider, {\n    value: allComponents\n  }, children);\n}","/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"Software architecture sometimes ends up being a very abstract topic, but a lot of interviews have architecture portions and I struggle separating experienced and junior software engineers when it comes to these. Often, they will both create an acceptable solution, so what sets the experienced architect apart?\"), \"\\n\", React.createElement(_components.p, null, \"I found that the first piece, often the most difficult to appreciate if not articulated, technical prediction. When you start working in complex environments and mixing and sharing services, you're going to run into countless issues. No one is going to figure out all of those problems before pushing a design, but someone with a lot more experience is going to be able to spot pain points and prepare teams for solving those issues. They may even make certain concessions based on their predictions and push back on theoretically strong ideas knowing they are easy places for issues.\"), \"\\n\", React.createElement(_components.p, null, \"Maybe a more obvious one, communication. Experienced architects are going to do a better job driving discussions to get value and forward moment vs excess discussion and talking in circles. They are much better at resolving conflict (either through respect or just communication navigation skills) to get everyone to make progress. They are also great for making sure that teams truly understand their pieces and integrations together. My biggest struggle trying to facilitate this conversation now is getting the nods of understanding, but doing a poor job making sure the important understanding is there which I've seen our more experienced developers accomplish.\"), \"\\n\", React.createElement(_components.p, null, \"Finally, a trend I noticed. No matter how confident a young architect is, they are always going to have concerns about not predicting the whole picture. Confidence in a young architect in my experience is also low and you're going to have to others double checking and second guessing their decisions. A more experienced architect is more confident in their prediction and comfort with what difficulties a design may run in to. That comfort with discomfort is something that everyone has to deal with (even outside of architecture) but I feel it plays more into roles with higher level views which can have wide spread impact.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"D:/coding/blog/content/life/expereinced_vs_young_software_architects.mdx\";\nimport React from \"react\";\nimport {graphql} from \"gatsby\";\nimport {MDXProvider} from \"@mdx-js/react\";\nimport {Link} from \"gatsby\";\nimport Layout from \"./layout\";\nimport Seo from \"./Seo\";\nconst shortcodes = {\n  Link\n};\nfunction PageTemplate({data: {mdx}, children}) {\n  return React.createElement(Layout, null, React.createElement(Seo, {\n    title: mdx.frontmatter.title\n  }), React.createElement(\"div\", {\n    className: \"post\"\n  }, React.createElement(\"h1\", null, mdx.frontmatter.title), React.createElement(\"p\", null, mdx.frontmatter.author, \" - \", mdx.frontmatter.date), React.createElement(MDXProvider, {\n    components: shortcodes\n  }, children)));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(PageTemplate, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const pageQuery = graphql`\n  query PostTemplate($id: String!) {\n    mdx(id: { eq: $id }) {\n      id\n      frontmatter {\n        title\n        author\n        date(formatString: \"MMMM Do, YYYY\")\n      }\n    }\n  }\n`;\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","MDXContext","useMDXComponents","components","contextComponents","emptyObject","MDXProvider","_ref","children","disableParentContext","allComponents","Provider","_createMdxContent","props","_components","assign","p","_provideComponents","React","MDXLayout","wrapper","shortcodes","Link","PageTemplate","mdx","data","Layout","Seo","title","frontmatter","className","author","date","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}